#@
Example  of any LP (Lisapet) abilities.
# @intr@exit
For now we can:

1. loops: 
    while, 
    for init; condition; post-expression
    for val <- iter() # magic for now
    for val <- [a,r,r,a,y] 

2. if-else statement
    if expr
        expr-block
    else
        expr-blok

3. compare operators and complex bool-expressions, including unary bool-inversion (!)
    a < 100 && b > 4 || a + b >= 1 || !(a > b * 10)

4. match-case
    match expr
        a !- expr1
        b !- expr2
        _ !- default-expression

5. complex math expressions, including unary (-): 
    res = a + b * (c -10 ** 2) / (7 - 5 * d)

6. functions 
    func definition: 
        func foo(a, b, c)
            a + b + c
    function call: res = foo(1, 2, 3) 

7. Lists
    declaration: nums = [1,2,3]
    usage:
        set val: nums[0] = 5
        get val: print(nums[2])

8. Dict
    declaration: dd = {'aa': 'hello', 'bb': 333}
    set val: dd['cc'] = 555
    get val: print(dd['aa'])

9. Struct (single-line syntax).
    struct User name, age, sex, phone
    user = User{name:'Catod', age:25, sex:male, phone:'123-45-67'}
    print('phone:', user.phone)
    
10 Struct
    block-definition
    block-constructor, 
    usage of nested member: struct.struct.field = val; val = struct.struct.field

11. Methods of struct
    func inst:TypeName foo(arg1, arg2)
        # doing something with instance, args. Same as other functions
        inst.field = arg1 + arg2 * inst.field

12. types of func/  method arguments.
    func foo(a:int, b:string) ...

13. List generator.
    [beginVal .. lastVal]
    useful for loops: 
    for x <- [1..10] ...

14. List comprehansions.
    [res-elem ; elem <- src; subVar = expr; guard ]
    [result-expression (element) ; element <- srcList; subVar = expression; bool-expression (filtre condition) ]
    List comprehension an contain 
        1 or more internal iterators (elem <- src), 
        0 or more sub-vars / sub-expressions for each iterator after iterator, 
        1 filter condition for each iterator after iterator.
        Next iterator can use elem from previous as a source (nice feature for flatten list of lists).

15. Lambda-functions and high-order  functions.

    # 1 arg
    f1 = x -> x + 2

    # many args
    f2 = (a, b, c) -> a * b - c

    # usage
    func foo(f, a)
        f(a)
    
    foo(x -> x + 2, 10)

    func bar(f, a, b, c)
        f(a, b) + c
    
    bar((x, y)-> x * y, 2, 3, 100)

16. Tuple type
val = (1, 2, c+3)
# TODO: left-arg tuple as a multi-declaration / multi-assignment

17. left-arrow operator `<-`
    # 1. Case: iter-assignment
    # for list, generator, list comprehentions
    for i <- [0..10]
        print(i)
    # for dict
    dictVal = {1:11, 2:22, 3:33}
    for key, val <- dictVal
        print(key, val)

    # 2. Case: append to collecition.
    # list
    nums = [1,2]
    nums <- 3
    # dict
    args = {'a', 1, 'b': 2}
    args <- ('c', 3)


--
@#

func fooPow2(x)
    # simplest math function
    return x * x

func unar(cond)
    inv = false
    if cond && ! inv
        print('inverted')

func sum(nums)
    # for over list
    res = 0
    print(33, nums)
    for n <- nums
        res += n
    res

func prime(x)
    # while
    # print('--------------------- $$$ ---------------------')
    n = 2
    q = n
    print('n:', n)
    while n ** 2 < x
        if n >3
            return
#        if x % n == 0
#            return false
        n += 1
    true

func fact(x)
    # for over init-, condition-, post- expressions
    r = 1
    for i=2; i <= x; i += 1
        r *= i
    r

func printVal(data, key)
    print(data[key])

# tests:
t1 = prime(7)

t2 = prime(8)

t3 = sum([1000, 200, 30, 4])
f10 = fact(10)

hello = "Hello print example!"
print(hello)
print("Hello print example!" + '!!')
print(fooPow2(5))
unar(true)
print( 10 )
print('is prime 11', t1)
print(t3)

# List, one-line constructor
names = ['Alladin','Bob','Colin','ddd']
names[3] = 'Dude'

# List, multiline constructor
lorem = list
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit," 
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua." 
    "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris"
    "nisi ut aliquip ex ea commodo consequat." 
    "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur." 
    "Excepteur sint occaecat cupidatat non proident," 
    "sunt in culpa qui officia deserunt mollit anim id est laborum."

# Dict, one-line constructor
colors = {'red':'#ff0000', 'green':'#00ff00', 'blue':'#0000ff'}

# Dict, multiline constructor
weekDays = dict
    1: 'Monday'
    2: 'Tuesday'
    3: 'Wednesday'
    4: 'Thursday'
    5: 'Friday'
    6: 'Saturday'
    7: 'Sunday'

weekDays[2] = 'Second day'

printVal(names, 3)
printVal(lorem, 0)

printVal(colors, 'green')
printVal(weekDays, 2)

func testDictIter(data)
    for key, val <- data
        print('dict-data', key, val)

testDictIter(colors)

# Structs

struct Product
    price:float
    amount:int

struct Book title:string, author:string, pages:int, prod:Product
books = list
    Book{title:'Green  gardens', author:'Bob Stinger', pages:100, prod: Product{price:10., amount:1111}}
    Book{title:'Blue, blue sky', author:'Ani Arabesquin', pages:200, prod: Product{price:20., amount:2222}}
    Book{title:'Silver sword of small town', author:'Arnold Whiteshvartz', pages:300, prod: Product{price:20., amount:3333}}


books[2].prod.price *= 1.1

func printBook(book)
    print(book.title, book.author, book.pages, book.prod.price)

func testBooks()
    for bb <-books
        printBook(bb)

testBooks()

# Methods of struct

struct Type1
    name: string
    id: int

func tip:Type1 setName(name:string)
    tip.name = name

func tip:Type1 getName()
    tip.name

func testType1()
    tp1 = Type1 {name:'noname', id: 1}
    tp1.setName('New-Name')
    print('tp1 name:', tp1.getName())

testType1()

# List comprehension

func testCompr()
    nums1 = [[x ** 2, y] ; x <- [5..7]; y <- [1..3]]
    print('nums1 = ', nums1)

    src2 = [[5, 1], [5, 2], [5, 3], [6, 1], [6, 2], [6, 3], [7, 1], [7, 2], [7, 3]]
    nums2 = [ x ; sub <- src2 ; x <- sub]
    print('nums2 = ', nums2)

    nums3 = [[x, x**3, y**2] ; x <- [1..10]; y = x ** 2; y < 50 && x ** 3 > 10]
    print('nums = ', nums3)

testCompr()

# Lambda function and high-order function

func testLambdas()
    
    func foo(f, a, b)
        a + f(b)

    f1 = x -> x * 10
    n1 = foo(f1, 2, 3)

    n2 = foo(x -> x * 100, 4, 5)

    # TODO: 1) append val to list : nums <- 5
    nn = [0,0,0,0,0]
    for i <- [1..5]
        nn[i-1] = foo(x -> x ** 2 , 1, i)
    
    print('lambda test:', n1, n2, nn)

testLambdas()



#@
@#

