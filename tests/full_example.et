#@
Example  of any LP (Lisapet) abilities.
# @intr@exit
For now we can:

1. loops: 
    while, 
    for init; condition; post-expression
    for val <- iter() # magic for now
    for val <- [a,r,r,a,y] 

2. if-else statement
    if expr
        expr-block
    else
        expr-blok

3. compare operators and complex bool-expressions, including unary (!)
    a < 100 && b > 4 || a + b >= 1

4. match-case
    match expr
        a !- expr1
        b !- expr2
        _ !- default-expression

5. complex math expressions, including unary (-): 
    res = a + b * (c -10 ** 2) / (7 - 5 * d)

6. functions 
    func definition: 
        func foo(a, b, c)
            a + b + c
    function call: res = foo(1, 2, 3) 

7. Lists
    declaration: nums = [1,2,3]
    usage:
        set val: nums[0] = 5
        get val: print(nums[2])

8. Dict
    declaration: dd = {'aa': 'hello', 'bb': 333}
    set val: dd['cc'] = 555
    get val: print(dd['aa'])

9. Struct (single-line syntax).
    struct User name, age, sex, phone
    user = User{name:'Catod', age:25, sex:male, phone:'123-45-67'}
    print('phone:', user.phone)
    
10 Struct
    block-definition
    block-constructor, 
    set val to struct.field (a.b = c)

11. Methods of struct
    func instance: TypeName foo(arg, arg)
        # doing something with instance, args. Same as other functions

12. types of func/  method arguments.


13. List generator.
    [beginVal .. lastVal]
    useful for loops: 
    for x <- [1..10] ...

14. List comprehansions.
    [res-elem ; elem <- src; subVar = expr; guard ]
    [result-expression (element) ; element <- srcList; subVar = expression; bool-expression (filtre condition) ]
    List comprehension an contain 
        1 or more internal iterators (elem <- src), 
        0 or more sub-vars for each iterator after iterator, 
        1 filter condition for each iterator after iterator.
        Next iterator can use elem from previous a source.

--
@#

func fooPow2(x)
    # simplest math function
    return x * x

func unar(cond)
    inv = false
    if cond && ! inv
        print('inverted')

func sum(nums)
    # for over list
    res = 0
    print(33, nums)
    for n <- nums
        res += n
    res

func prime(x)
    # while
    print('--------------------- $$$ ---------------------')
    n = 2
    q = n
    print('n:', n)
    while n ** 2 < x
        if n >3
            return
#        if x % n == 0
#            return false
        n += 1
    true

func fact(x)
    # for over init-, condition-, post- expressions
    r = 1
    for i=2; i <= x; i += 1
        r *= i
    r

func printVal(data, key)
    print(data[key])

# tests:
t1 = prime(7)

t2 = prime(8)

t3 = sum([1000, 200, 30, 4])
f10 = fact(10)

hello = "Hello print example!"
print(hello)
print("Hello print example!" + '!!')
print(fooPow2(5))
unar(true)
print( 10 )
print('is prime 11', t1)
print(t3)

# List, one-line constructor
names = ['Alladin','Bob','Colin','ddd']
names[3] = 'Dude'

# List, multiline constructor
lorem = list
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit," 
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua." 
    "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris"
    "nisi ut aliquip ex ea commodo consequat." 
    "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur." 
    "Excepteur sint occaecat cupidatat non proident," 
    "sunt in culpa qui officia deserunt mollit anim id est laborum."

# Dict, one-line constructor
colors = {'red':'#ff0000', 'green':'#00ff00', 'blue':'#0000ff'}

# Dict, multiline constructor
weekDays = dict
    1: 'Monday'
    2: 'Tuesday'
    3: 'Wednesday'
    4: 'Thursday'
    5: 'Friday'
    6: 'Saturday'
    7: 'Sunday'

weekDays[2] = 'Second day'

printVal(names, 3)
printVal(lorem, 0)

printVal(colors, 'green')
printVal(weekDays, 2)

struct Product
    price:float
    amount:int

struct Book title:string, author:string, pages:int, prod:Product
books = list
    Book{title:'Green  gardens', author:'Bob Stinger', pages:100, prod: Product{price:10., amount:1111}}
    Book{title:'Blue, blue sky', author:'Ani Arabesquin', pages:200, prod: Product{price:20., amount:2222}}
    Book{title:'Silver sword of small town', author:'Arnold Whiteshvartz', pages:300, prod: Product{price:20., amount:3333}}


books[2].prod.price *= 1.1

func printBook(book)
    print(book.title, book.author, book.pages, book.prod.price)

func testBooks()
    for bb <-books
        printBook(bb)

testBooks()

# Methods of struct

struct Type1
    name: string
    id: int

func tip:Type1 setName(name:string)
    tip.name = name

func tip:Type1 getName()
    tip.name

func testType1()
    tp1 = Type1 {name:'noname', id: 1}
    tp1.setName('New-Name')
    print('tp1 name:', tp1.getName())

testType1()

# List comprehension

func testCompr()
    nums1 = [[x ** 2, y] ; x <- [5..7]; y <- [1..3]]
    print('nums1 = ', nums1)

    src2 = [[5, 1], [5, 2], [5, 3], [6, 1], [6, 2], [6, 3], [7, 1], [7, 2], [7, 3]]
    nums2 = [ x ; sub <- src2 ; x <- sub]
    print('nums2 = ', nums2)

    nums3 = [[x, x**3, y**2] ; x <- [1..10]; y = x ** 2; y < 50 && x ** 3 > 10]
    print('nums = ', nums3)

testCompr()

# Lambda function and high-order function

func testLambdas()
    
    func foo(f, a, b)
        a + f(b)

    f1 = x -> x * 10
    n1 = foo(f1, 2, 3)

    n2 = foo(x -> x * 100, 4, 5)

    # TODO: 1) append val to list : nums <- 5
    nn = [0,0,0,0,0]
    for i <- [1..5]
        nn[i-1] = foo(x -> x ** 2 , 1, i)
    
    print('lambda test:', n1, n2, nn)

testLambdas()



#@
@#

