
# TODO List

#== change `iter(args)` magic implementstion to inbound function (custom python function func__iter(args)->IterGen )

#== DONE!
#@ 
multiline comment
@#
x = 2 #@ inline comment @# + sum([10, 20])
#@

#== store content of comments as a runtime metadata

#== dict DONE

#== list slice
subVals = arr[3:-2]

# list | string math mult, concat

'abc' * 3 -> 'abcabcabc'
[1,2,3] * 2 -> [1,2,3,1,2,3,1,2,3]

'acb ' + 'xyz' -> 'abc xyz'
[1,2,3] + [4,5] -> [1,2,3,4,5]

#== list generator
[0..10]
[x ** 2 | x <- [0..10]]
[y * x | x <- [0..10], y <- ['a'..'n']]
[x ** 2 | x <- [0..10] | x % 2 != 0]


#==
''' 
multistring
'''

#== multiline expr
# concat all sublines before make expression process

if (expr1 
    && expr2)

#== possible sugar
# case if: with no operator between line use && or defined default operator
#    if (&& ..) if (|| .. ) - definition of default
# e.g: 
# if (||
#     a > 5
#     a % 2 != 0)
#
#

foo( ag1,
    arg2,
    bar( a, b, c)
)

#== concat strings
str = (
    'Hello '
    "new string!"
)

# not sure >>>
nums = [1, 2, 
        3, 4]

data = {
    'a': 1,
    'b': 2
}
# <<<

#== sugar for collections - skip commas between lines (auto-complit for interpretation)

#== list
strings = list
    'Hello world!'
    'Helo desktop!'

#== DONE
data = dict
    'a': 1
    'b': 2

#== struct

struct TypeName
    field1: str
    field2: type

func TypeName.foo(inst, arg1, arg2)
    expr1
    espr2
    inst.field1 = arg1

inst = TypeName

inst.field1 = 'new value'
print(inst.field1)

inst.foo(11, 22)



#== Think about tail-recursion.
Tranform tail recursion to loop.

func foo(arg)
    if expr1
        return expr2
    arg2 = expr3
    foo(arg2)

@#