
# TODO List

# Necessary things: 

1. string functions: 
    element like list: name[0], "abc"[1]
    # split() # regexp added
    # join()
    # replace() # regexp added
    # len() for string
    # tostr([int]), 
    # tostr(anyval) # any type, 
    # string[index] - get elem
    # string + string
    string[a : b] - slice
    TODO:
    tostr(dictVal, keyOrder) 
    tostr([a..b]) # gen obj
    
    decode(from bytes) / encode (to bytes) 
    

1.01 import python-implemented modules from /libs

1.02 container of functions aka namespace or static methods. 
# call
A.foo(a, b)
# def
A func foo(a, b)
    ..
func A foo(a, b)
    ..

group A
func A.foo(a, b)
    ..


1.2 method sugar
    #  method-like syntax for base types
    func val:string encode(encoding='utf-8')
        ... # do something
    1) #DONE bind builtin functions: dict:keys,items, intersect,diff; string:slice,join,split; list:merge,intersect,diff; 
    2) #DONE call builtin method: 'aa bb cc'.split(' '); text.split(re`\s+`)
    # Not sure we need next parts because 2 classes of types already implemented:
    # 1) builtin type: with type-bound methods
    # 2) structs: with regular methods
    3) user-defined binding: func val:list foo(arg:int)
    4) test user-defined 


2.0 module math
2.1 module `file`
    read(filepath)
    write(filepath, content)

2.2 module `json`
    to(data_obj): json_str
    from(json_str): data_obj


2.3.1 Check type of struct instance>> var :: TypeName
2.3.2 Check match type of struct instance>> _::TypeName


2.4 TODO: More types:  
    byte, common numeric,
    common struct, implemented struct
    Maybe (Some, Nothing).

2.5 OpAssing:
        # TODO: think about multiresult expressions: a, b, c = triple_vals(); // return 11, 22, 'ccc'
        # TODO: thik about one way of assignment: (something) = (something)
        # DONE: type reset in reassign

NEED FIX:

    -2. #DONE compatibility of struct var to null value: 
        struct A x:int
        a:A = null
    -1. func foo(d:dict, nn:list)
            # fix confuse about construct / type in func args for: dict, list

    1. print struct instance
        - ',' separator -> ', '
        - add quotes for strings

    4. multiassign in: 
        # python-like immediate assign: not sure. 
        for var1, var2,.. <- src
        # auto-unpack tuples, could be resolved by next reassign: a, b = n 
        for n <- [(1,2), (3,4), ] # but easy to use

 
    loop over dict
    - # OK. works fine.
        for k, v <- dict
    - #DONE data.keys() ; dkeys(data) # dict keys
    - #DONE for item <- ditems(data) ; for item <- data.items()  # key-val pairs from dict


3.2. # DONE Type auto-casting. Important for struct constructors, function args

3.2.1 type auto-conversion in math operators.
int + float
int / int (if result is not int)



4. save code-source into expression as some metadata, and debug/error info (at least whole line)


5. error handling (with printing source code)
    # DONE: parser errors, interpretation errors
    eval error: 
        incorrect type, 
        name(var, type, func, stt.method etc) not found
        argument error for (arg count, arg type): functions, constructors, operators, for-statement, sequence-gen,
        zero div (x / 0)
        key/index error for collections
        type-casting error(for example: list to int, non-number string to float )
        IO-error: read/write data

5.2 exception handling.
We dont have exceptions like python, java 
We will handle critical errors.

crit!
!crit

catch, get, pickup, 
catch crit
    processing
?crit
    processing


8. logging | with named args: #debug: log(d: (msg, arg1, arg2)) #info log(i: ("Found %d records", 15))
    module `logs`

9. input-output: 
    files, 
    console, 
    network, 
    db,

10 serialization: 
    1) data objects (collections, struct inst) 
    2) executive tree (prepared exec file)

12 Functions: 
12.1 named args for function: func foo(name:string) # call: foo(name:'Abc')
12.2 other args in `func(a, b, other...) : foo(1, 2, 33, 44, 55, 66, 77) other = [33, 44, 55, 66, 77]
12.3 default values of args func foo(x, y=3) :: needed
12.xx other possible extensions of basic scheme of function:
    - undeclared args passed by name (like kwargs in python):: thinkable
    - function / method overload: totally not applicable to strategy of floating number of args like default-val and named-args / No.
    - shortening syntax with obvious-arg in lambda (like scala) `x -> x + 2` => `_ * 2`: not necessary but :: thinkable
    - unused/unnamed var `_` for function args foo(_, x), multiple assignment `for key, _ <- dict`:: thinkable

    # type-groups: 
        numeric, bool, string, list, tuple, dict, struct, function, regexp, [set, maybe, tree, ...]

func foo(a, b, [c=0, d=''])
    ..

func bar(a, b, [c...])
    for n <- c /: ..
--
func foo()
    1
func foo(x)
    x * 2
func foo(x, y)
    x + y
func foo(nums:list)
    sum(nums)
func foo(x, y, nums...)
        [x + y * n ; n <- nums]
    

13. Interfaces as a some list of method signatures.


14.9.2 think about transfer matched regexp to sub-expression 
match s

    pattern@re`\d+([a-z]+)` !- res = pattern ?~ s
    pattern := re`\d+([a-z]+)`i !- 
    re`\d+([a-z]+)` => rx !- res = split(s, rx)
    re`\d+([a-z]+)` => p@(x) !- 

# transfer foundg roups
    re`(\d+) (\w+)` :> a, b !- print(a, b)
# transfer regexp rom pattern
    ptt@re`(sub)` !- res = ptt ?~ sourceString

14.11 var of whole pattern, or subset
match nn
    x@[*] !- # x - ane list == nn
    [x@[*], y@[*], *] !- # x, y - vars by subpatterns
    [ a@<_,_,_>, ee@*] !- # sets of subelements, a - subset,  ee - others
    x@TypeA{} !- # var with struct instance

- regexp-assign should differ from subval-assign
    for example
    [a, b@[c, d]] !- 
    [a@~re``, b@re``] !- # a - regexp, b - value


14.13.2 check type pattern, complex check type
    # questions:
        ? :: int, x :: (int | float)

    # complex type
        x :: [int], y :: {string:int}

14.0.1 Multiline and singleline cases: 
match val
    ptr /: x = 1; res = 2 + x
    ptr2
        y = 2
        res = 2 + y


14.0.2 Last expression is a result of match

func foo(a)
    match a
        ptr1
            b = 2 + a
            b
        _ /: a + a


14.5 extended case of `?>` 'has values'
    thinking, not sure:
    X [*(12, 15)] !- list has values in parentheses with star, other values doesn't matter
    [* 12, 15] !- has values in such
    [? 12, 15] !- can have values
    [?> 12, 15] !- has values in any order
    (1,2,3) ??> nums # any of: ?,?,2,?,?
    (1,2,3) *?> nums # all in any order: 2,?,3,?,1
    (1,2,3) =?> nums # all in the same order: 1,?,2,3,?


15.2 regexp operators
# replace
(re`\s`i : `-`) /~ 'source string abc'
re`\s`i >> "-" /~ 'source string abc'
re`\s`i / "-" /~ 'source string abc'
'source string abc' <= (re`\s`i /~ ,'-')
'source string abc' -+ (re`\s`i /~ ,'-')

# split 
- overloaded `/`
'source string' / re`\s+`
# str-str split
'source string abc' / ' '


16.1 Overload operators
Add API for overload operators.
1. exist operators
def overlod(operator, leftType, ritghType=Any, handler)
..
handler = ...
overload('>>', TypeAny, TypeList, handler)

2. new operators by python (not sure) 




21.1 reading iterator. read values from sequence in the loop iteration like 
    val = iter(src) # src is collection or generator
        it should init iterator and save instance in first call, then call next() method in each iteration
        it should have reset() method
        # sugar: val <= src // ?

22.1 overload += to avoid copying original list.
    // Looks too complex in current implementation where x += y is the x = (x + y)
    // may be possible if refactor to call left.do() before right.do()
    possible solution:
    for a, b, c <- iters(list1, list2, list3)

23. Common filesystem-location of installed libraries for importing (not sure we need it now).  

24. TODO: Should we implement full inline block syntax?   
Like `for a <- b /: expr :/ ; next-block`  
if cond /: expr :/ else /: expr :/
Thinking

16.1 inline shortening (?):
(control /: sub-expr)
# if
(? x < 5 /: print(x))
# for
(@ i <- [] /: print(i))
(@ i=0; i < 5; i += 1 /: print(i))

25. enum
default values is int from 1: 1,2,3...
# inline
enum Color  Red, Green, Blue # >> 1,2,3
enum Color:int  Red 5, Green 10, Blue # >> 5, 10, 11
# block
enum Color: int
    Red 0xf00
    Green 0x0f0
    Blue 0x00f

# usage
match color
    Color.Red !- ...


26. anonimous struct

struct {name: 'Bob', age: 25}

#shortened sugar:
${name: 'Bob', age: 25}
~{ name: 'Bob', age: 25}
{s name: 'Bob', age: 25}

27. parents method and direct parent
# thoughts about OOP

struct C c:int
struct D(A,C) d1:int, d2:float

func d:D f1(x, y)
    d.f1(x, y)
    d.a1 = 1
    d.A.f1(x, y) # ??
    d.super().f1(x, y) # ??
    super(d).f1(x, y) # for methods only # ??


# -------------------------
Not sure:

14.2 maybe refactor !- as a start-line operator? with explicit indent for any sub-expressions. Not sure.
    match x
        !- 1
            expr
        !- 2
            expr

14.2 Looks like multi-if will be more useful:
    if
        a < 5
            expr1
        b == 7
            expr2
        a < b /: expr3 # same line block
        _
            expr4

# -------------------

Fixes:
    2. #DONE multi-args constructor for inherited struct type 
        A a:int
        A(a) 
        B b : int
        B(a, b) 
    3. # DONE fix case with comprehensions [1..3] + [5..8]

# DONE think about type.related methods: 
    'abc'.encode('utf-8')
    nums = []; nums.len()
    
2.3 # DONE Check type operator 
    var :: type

14.9 # DONE  // perspective: regexp match:
    rx(`[1-9][A-E]+`) !-  regexp returning by function rx (not implemented yet), or some another inline implementation of regexp
    /`[a-f]+`in/ !- 
    res@rx(`(\d+)([a-z]+)`) -> a, b, c ?: a != '0 ' !- res - regexp-results, a - 1-st full-match, b, c - parts of 1-st group 
    `(\d+)([a-z]+)`iu ^ a,b,c !- 
14.10 #DONE // mixed
    [A{}, A{*}, B{b1,*}] !- list with structs
    {k: B{b2:'hello'}, *} !- dict that has inst of B with b2=='hello' in value

14.13 #DONE  case of other val types: int, float, numeric, string, bool, null, 

    {a: b::int, c: d::list, e: ::float}

    # :: as a type-checker in non-match places
    if a :: int # type (a) == int
    [a :: int, b] :? b :: float !- 

    (val) (:: type)
    _ :: int
    x :: int
    1 :: int
    1 :: float
    # combo cases 
        x :: (int | float)  x :: (int | float)
        [_::int] [a :: int, b :: float, _ :: int] [? :: int, x :: string] 
        {a: b :: int, c :: string : _:: float} 
        {::string : ::int}
        _{a: val :: int} _{ a : _ :: int} _{ a :: int}

5. #DONE tostr nested vals: 
    > py -m run -c "print(tostr([1,2, (3,4)]))"
    [1,2,'3':4]
    > py -m run -c "print(tostr([1,2, (3,4, 5)]))"
    Error handling:  too many values to unpack (expected 2)

14.3 #DONE refactor usage of MatchPtrCase

15.1 regexp
# DONE rx = re`abc`iu
# DONE match
rx =~ 'source string abc'

# DONE find
rx ?~ 'source string'

# DONE replace(src, rx, repl)

# DONE split(src, re``)

17. #DONE Fix escapes in ` `-strings.
all escape sequences should not work, except \`.

14.12 #DONE any struct, thoughts
    _{} !- # any struct

    // other variants:
        Nn@TypeName{} !- # Nn - var with instance
        @{} !- #  struct with any type
        :struct !- any struct ?


14.4 #DONE match cases of collections
    ## pattern quantifiers: 
        `_` - some one, 
        `?` - maybe one (nothing or one), for dict means full pair
        `*` - any things (nothing or more), for this implementation - applicable to the last position in sequene only
    ## quantifier works only in value-role, it can't be part of math or logic expression
    [?, *], [5, *], {_:'abc'} - is ok
    [5 + *] - incorrect

    - # DONE list
    - # DONE tuple
    - # DONE dict
    - # DONE sub-val
    - # DONE sub-var
    - # DONE sub-wildcard
    - sub-? [#done] (#done) {#done}
    - sub-* [#done] (#done) {#done}

    # // list patterns
    [] !-  empty list
    [x] !-  list with 1 element, x - local var which will associated with value by position
    [x,y,z] !-  n-elements
    [x, y, *] !- basic *-pattern: n-elems in the beginтштп of list with more possible next

    X [*,12,*] !- list has value
    X [* ,12, x,*] !- list has value, `x` - next elem ([*,x,12,*] - prev) ??
    X [*, x] !- last elem

    # // tuple patterns, the same patterns as list
    () !- empty tuple
    (a, b, ?) tuple with 2 required elements and 3-rd - possible
    (_ , _) tuple with 2 elements, no vars assigned
    (?) tuple, one elem or none
    (*) tuple with any number of elems
    (_ , *) one or more

    # // dict patterns
    {} !- empty dict
    {*} !- any dict
    {k: _} !- dict with 1 key-val pair `k` var with value of key
    {'key': v} !- dict has only 1 key=='key', v - var with value by key 
    {'key': v, *} !- dict has key 'key', and possibly has another key:vals
    {'k1':x, 'k2':y} !- several keys in dict 
    {'k1':x, 'k2':y, *} !- several keys with more
    {k: 'red'} != dict has value 'red', k - var with key value

14.7 #DONE multi-case in match
`|` - lowest prior inside pattern
match n
    2 | 3 | 5 !- ...


14.8 #DONE bool expression (guard) in match-case
bool cases: <, >, >=, <=, ?>, !?>, len() == 5
pattern :? guard !- sub-block
match n
    _ :? 11 ?> n !-

14.6 #DONE Struct in Pattern matching:
    - struct as user-defined type: TypeName{...}
    - struct common (?) we don't have common struct now
    # // struct types
    struct A a1:int, a2, a3
    struct B(A) b2:string
    struct C c1:list, c2:tuple
    # cases:
    A{} !- instance of A with any field values, or any chidren of A (like B)
    A{a1:10} !- instance of A with `a1 = 10`
    A{a1:aVar} !- instance of A, assigning val of field `a1` into variable `aVar`.
    B{} !- instance of B (or his children)
    B{a1: 11} !- match by B-type with inherited `a1` field
    B{b2: 'abc'} !- match by B-type (or children) by fields value
    C{c1:[1,*]} !- struct with list in field
    struct has defined list of fields, so `_`, `?`, `*` sub-elements don't make sense for structs. maybe for anonimous struct, if will be implemented.


>>>


3.1 # DONE import x > * `instead of ` import x.* (?) thinking

16. # DONE 1-line if/for/while: 
    for x <- vals /: doit(x); y = x + 2; print(x, y)
    # operator variants: !-  !~  !:  ::  \:  /:  |:  :|



31. # DONE Struct constructor
        func TypeName(a, b, c)
            Typename{name:a, addr:b, age: c}
            
        val = TypeName('Vasya', 'Green st., 12/5', 20)
        note: it have to be implemented (instead of `T{...}`) but we can make default implementation by order of fields in definition

-------------------------

# Perspective things: 
0. build.py - builder of *.et files with resulting binary files (serialized executable object).
1. Maybe type 
2. default, unnecessary and named function args
3. tail-recursion optimization
4.1 Duck-type for structs:: func f(arg:struct{foo(int, float), bar(string)}) // ? not sure
4.2 anonimous structs inst = struct{name: 'Abc', num: 123}; possible sugar: ${name: '', num:123}
5. composition of functions: foo . bar : arg ;; foo . bar < arg
6. carrying
    foo(a,b)
    foo2 = foo(a;) -> func.carr[foo, a] -> foo2(b)
    foo(a;) >> | (arg2) -> foo(a, arg2) |
    foo2(arg2) -> foo(a, arg2) 
7. common types: (tree, queue, set, pair ) with operations: applay func to each, clone, merge, insert, fold, map, etc.
8. ~[s, s <- "..."] gen by string: solution (1) `~` operator as a list-to-string convertor


#== anonimous func object (multiline)

foo = func (args...)


#== works as is by native pythons functionality
# list | string - mult *, concat +

'abc' * 3 --> 'abcabcabc'
[1,2,3] * 2 --> [1,2,3,1,2,3,1,2,3]

'acb ' + 'xyz' --> 'abc xyz'
[1,2,3] + [4,5] --> [1,2,3,4,5]


#= 
# Native regexp
pattern cases:  /pattern/mod ; |pattern|mod ; <pattern>mod ; %pattern%mod, 
numsRx = /^[0-9]+$/in
numsRx.match(strVal) # bool
res = numRx.first(strVal) # string
resList = numRx.find(strVal) # [string]
grs = numsRx.groups(strVal) # [[string]]

rx = /`^Regex$`in/


#==
# Maybe type: Nothing, Thing
x = maybe(1) # @yep(1), (? val)
x = nothing # @nop , (?-)


#==
# unary increment, decrement
i++ # i += 1
i-- # i -= 1


#== store content of comments as a runtime metadata


#== multiline expr
#== possible sugar


#== concat strings
str = (
    'Hello '
    "new string!"
)


# case if: with no operator between line use && or defined default operator
#    if (&& ..) if (|| .. ) - definition of default
# e.g: 
# if (||
#     a > 5
#     a % 2 != 0)
#
#


#== Next line operator, next line after beginning, 
# Second line starts with operator after 1 indent (like subline in block). If no indent - just new expression with unary operator (or error)
# Next lines after 2-nd - the same indent.
res = (long_expressions)
    + (next-expression) * (next-expression)
    - (3rd-line--expression)


#== Type alising, make sense only for strict typeing mode (not implemented)
type intN3 [int, int, int]
type intN3 int[3]


#== 
# Named func args

func foo(user:User=null, name: string, age: int)
    user ?: getUser(name, age) 
    # return user if not null, otherwize - return result of getUser()
user = foo(age=22, name='Vasya')


#==
# Variadic  functions, just preliminary thinking

foo(arg1:string, arg2:float, ...args3:int) # any number of values after 2-nd arg.

# after vaiadic var-list only named args (future feature) can be used. declaration:
func foo2(arg1:float, arg2:float, ...arg3:int, narg1:string, narg2:string) ...
func foo2(arg1:float, arg2:float, arg3:int ... , narg1:string, narg2:string) ...

# arg:int ... the same as:  arg:int [] for usage  in function body 
# call:
foo2(1.1, 2.2, 31, 32, 33, 34, narg1:'a', narg2:'b')

# unpack list using it as many vals
func foo3(...args) -> for val <- args ...

# call
args = [1,2,3,4,5]
foo3(args...)


#==  func type
func foo(a:int, b:int): int
    a + b
# or 
func foo(int, int): int
foo(a, b)
    a + b


#==
# func overload (?)
func foo()

func foo(a:int, b:int)

func foo(a:string, b:int)

#==
# composition of functions are possible, by `.` or another
func foo(a)
func bar(a)
func buz(a)

buz(bar(foo(12)))
foo . bar . buz : (12)
foo bar buz $ 12
foo * bar * buz(12)
foo + bar + buz(12)
foo ~~ bar ~~ buz : 12


#== Think about tail-recursion.
Tranform tail recursion to loop.

func foo(arg)
    if expr1
        return expr2
    arg2 = expr3
    foo(arg2)


########################### Done section ############################# 
@#

#== DONE!
#@ 
multiline comment

x = 2 #@ inline comment @# + sum([10, 20])

@#

#@

#== DONE
change `iter(args)` magic implementstion to inbound function (custom python function func__iter(args)->IterGen )

#== dict DONE
data = {'a': 1, 'b': 2, c: [5,6,7]}

## Multiline collection constructor

#== list DONE
hellos = list
    'Hello world!'
    'Helo desktop!'

#== dict DONE
data = dict
    'a': 1
    'b': 2


#== DONE
# sugar for collections - skip commas between lines in multiline constructor


#== list slice # DONE
subVals = arr[3:-2]


#== DONE
# struct method

struct User
    name: string 

func u:User setName(name:string)
    u.name = name

# Contexts().types['User'].__typeMethods['setName'] = Function('User@setName')

user = User{name:'Markus'}
user.segName('Lukas')

print(user.name)


#== DONE
# typed func args 
func foo(name:string, age: int)


#== DONE 
# list generator
[0..10]

#== DONE
# list comprehention
[x ** 2 | x <- [0..10]]
[y * x | x <- [0..10], y <- ['a'..'n']]
[x ** 2 | x <- [0..10] | x % 2 != 0]


#== DONE
''' 
python-like
multistring
'''


#== DONE
# multiline func, definition and call (multiline in-brackets expression)

func foo (
    arg1:int,
    arg2: float,
    arg3: string 
)
    arg1 * arg2 - sum(arg3)

foo( ag1,
    arg2,
    bar( a, b, c)
)

#= DONE
# the same about for, if statements, 

# concat all sublines before make expression process

# if - DONE
if (expr1 
    && expr2)

# for - DONE
for (i=0; i<5; i += 1)

# dict DONE

d = {
    a: 1,
    b:2
}

# list DONE

nn = [1,2,
    3,4,
    5] 

# comprehension DONE
nn = [
    x + y;
    x <- nums1;
    y <- nums2;
    z = (x + y) ** 3;
    z % 5 > 1
]


#== DONE
# Lambdas, func-object, func-object call
foo = x -> x ** 2
n1 = foo(7)
foo2 = x, y -> x ** 2
n2 = foo2(5, 2)
foo3 = (x, y, z) -> (x + y) * z
n3 = foo3(2, 3, 100)


# High-order function def
#@ questions: 
1. instance of function: create, store, call
2. local context around function and into it
3. closures: how to store local declarations (local <1 lvl upper> context), controll list of used vars, or use them all?
#@

func foo(ff, arg)
    ff(arg * 2)

f1 = x -> x * 3
n1 = foo(f1, 5)
n2 = foo( x -> 2 ** x , 5)


#== DONE
# add to list or dict, back order of `<-` opertator: right add to the left
nums = []
nums <- 12
data = {}
data <- ('key', val)


#== DONE
# Type inheritanse 

struct A member1: int

struct B (A) member2: bool
# or
struct B
    type A
    member2: bool


#== DONE
# Ternar operator ==>>  expr ? expr : expr
res = condition ? valueIfTrue : valueIfFalse


#== DONE
# Val or Val operator  ?:
    `expr1 ?: expr2` # for non-number values, 
    # syntax sugar for ternar operator with condition: (expr1 != null and expr != false)
    # operator that is returns left val if it not a null/false, otherwize - return second


#== DONE
# Operator `in` as condition "collection has elem"
# for list, finds val, the same for tuple
value in [1,2,3] ...
# for dict, finds key
value in {'a':1, 'b':2,...}
# for anonimous struct?
# think about  non-word operators  instead of `in`
if 'Herakl' ?> heroes 


#== Done as `-` minus opreator for left-collection
# list pop
nums = [1,2,3]
x = nums[-1]
delete nums[-1] # nums - index; nums - [0], nums - [-1],  # 
dd = {'a':1, ..} # dd - ['a']

#== Done as `-` minus opreator for left-collection
# delete operator, find nearest context with var by name and remove it from found context
nums = [1,2,3,4,5]
x = 123
delete nums[2], x


#== DONE
# string formatting by %tpl
# string formatting by internal includes like {varName}, $varName, @varName, @{exp(res.sion)}

#== DONE
# sub-expression in if block 
if val = foo(); val > 10 ...
# last sub is condition

#== DONE
# else if - `sugar` for `if` into `else` block 
if cond2
    expr1
else if cond2
    expr2
else
    expr3


#== DONE
# closures of passed or returned lambdas / local funcs
#@
phases of implementation
1. just pure function: get args, return result, no usage of vars out of lambda
2. use near local context (where lambda was defined)
@#
for i <- iter(20, 30)
    bar(x -> sum(x) - 100, i)

@#


0. CI
    # DONE run.py - console script for run *.et files with console output.
    run.py - add preload of importable modules
    # DONE run -m --multirun 
        -s --datasource "source" # add option for multi-running compiled ET and datasource
        -j -json-source "file" # datasource from from json file
    # DONE run.py -r varname # show result / value of specified variable
1. # DONE String formatting. ~"{var}", "... %s ..." << (var)
2. # DONE one-line block: expr; expr; expr
3. # DONE import modules

6. # DONE else if
7. # DONE if sub-expression: if x=foo(); x < 5 ...
14. # DEPRICATE match-case block start in the same line: # It looks as over-sugaring # 
    match n
        1 !- if cond
            expr1
        2 !- for i <- nlist
            foo(i)

15. # DONE slice of iter-gen: [1..10][3:5]. include tolist into slice method, or add slicing method to iter-get (?)
17. # DONE: Not-in-list oper: !?> # if x !?> nums ... == if !(x ?> nums) ...

18 # DONE loop-breacking operators in `for`/ `while`
    looks like it should be an extra case in block execution, like return case.
    - continue
    - break

19. # DONE - function as object. 
    # if function not just defined name but result of expression: (lambda)(), funcs[key](), foo()()
    # func should be an expression which returns function object

20. # DONE Issue: listVar <- (tuple, item) works not correct

21. # Refuse ` var <- sequence` out of `for` statement.
    looks like it will provoke not clear interpretation like redefinition of listVar in `listVar <- list`.

22. # DONE by `+`
     append many values to list `res <- vals`, like dict has
    solution `list += [a, b, c]` looks ok
    check and fix cases: list + list, string + string

22.2 # DONE check string
