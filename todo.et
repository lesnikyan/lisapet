
# TODO List

# Necessary things: 

1. #DONE String formatting.
2. #DONE one-line block: expr; expr; expr
3. import modules
4. save code-source into expression (at least whole line)
5. error handling (with printing source code)
6. else if
7. #DONE if sub-expression: if x=foo(); x < 5 ...
8. logging
9. input-output: files, console, network, db,
10 serialization: 1) lang objects (collections, struct inst) 2) whole executive tree (prepared exec file)
11. struct constructor without field names: A{1, 2.0, 'abc'}


# Perspective things: 
1. Maybe type 
2. default, unnecessary and named function args
3. tail-recursion optimization
4. anonimous structs
5. composition of function
6. carrying
7. common types: (tree, queue, set, pair ) with operations: applay func to each, clone, merge, insert, fold, map, etc.


#== func object

foo = func (args...)


#==
# sub-expression in if block 
if val = foo(); val > 10 ...
# last sub is condition


#== else if - `sugar` for `if` into `else` block 
if cond2
    expr1
else if cond2
    expr2
else
    expr3


#== works as is by native pythons functionality
# list | string - mult *, concat +

'abc' * 3 --> 'abcabcabc'
[1,2,3] * 2 --> [1,2,3,1,2,3,1,2,3]

'acb ' + 'xyz' --> 'abc xyz'
[1,2,3] + [4,5] --> [1,2,3,4,5]


#= 
# Native regexp
pattern cases:  /pattern/mod ; |pattern|mod ; <pattern>mod ; %pattern%mod, 
numsRx = /^[0-9]+$/in
numsRx.match(strVal) # bool
res = numRx.first(strVal) # string
resList = numRx.find(strVal) # [string]
grs = numsRx.groups(strVal) # [[string]]


#==
# Maybe type: Nothing, Thing
x = maybe(1) # @yep(1), (? val)
x = nothing # @nop , (?-)


#==
# unary increment, decrement
i++ # i += 1
i-- # i -= 1


#== store content of comments as a runtime metadata


#== multiline expr
#== possible sugar


#== concat strings
str = (
    'Hello '
    "new string!"
)


# case if: with no operator between line use && or defined default operator
#    if (&& ..) if (|| .. ) - definition of default
# e.g: 
# if (||
#     a > 5
#     a % 2 != 0)
#
#


#== Next line operator, next line after beginning, 
# Second line starts with operator after 1 indent (like subline in block). If no indent - just new expression with unary operator (or error)
# Next lines after 2-nd - the same indent.
res = (long_expressions)
    + (next-expression) * (next-expression)
    - (3rd-line--expression)


#== Type alising, make sense only for strict typeing mode (not implemented)
type intN3 [int, int, int]
type intN3 int[3]


#==
# struct constructors
struct A a:int, b:int, c:bool

func newA(a, b, c)
    A{a:a, b:b, c:c}

func new.A(a, b, c)
    A{a:a, b:b, c:c}

a = new.A(1,2)
a = A.new(1,2)
a = A.make(1,2)

#== overloading
func new.A(a, b)
    A{a:a, b:b, c:true}


#== 
# Named func args

func foo(user:User=null, name: string, age: int)
    user ?: getUser(name, age) 
    # return user if not null, otherwize - return result of getUser()
user = foo(age=22, name='Vasya')


#==
# Variadic  functions, just preliminary thinking

foo(arg1:string, arg2:float, ...args3:int) # any number of values after 2-nd arg.

# after vaiadic var-list only named args (future feature) can be used. declaration:
func foo2(arg1:float, arg2:float, ...arg3:int, narg1:string, narg2:string) ...
func foo2(arg1:float, arg2:float, arg3:int ... , narg1:string, narg2:string) ...

# arg:int ... the same as:  arg:int [] for usage  in function body 
# call:
foo2(1.1, 2.2, 31, 32, 33, 34, narg1:'a', narg2:'b')

# unpack list using it as many vals
func foo3(...args) -> for val <- args ...

# call
args = [1,2,3,4,5]
foo3(args...)


#==  func type
func foo(a:int, b:int): int
    a + b
# or 
func foo(int, int): int
foo(a, b)
    a + b


#==
# func overload (?)
func foo()

func foo(a:int, b:int)

func foo(a:string, b:int)

#==
# composition of functions are possible, by `.` or another
func foo(a)
func bar(a)
func buz(a)

buz(bar(foo(12)))
foo . bar . buz : (12)
foo bar buz $ 12
foo * bar * buz(12)
foo + bar + buz(12)
foo ~ bar ~ buz : 12

# closures of passed or returned lambdas / local funcs
#@
phases of implementation
1. just pure function: get args, return result, no usage of vars out of lambda
2. use near local context (where lambda was defined)
@#
for i <- iter(20, 30)
    bar(x -> sum(x) - 100, i)


#== Think about tail-recursion.
Tranform tail recursion to loop.

func foo(arg)
    if expr1
        return expr2
    arg2 = expr3
    foo(arg2)

@#

#@
########################### Done section ############################# 
@#

#== DONE!
#@ 
multiline comment

x = 2 #@ inline comment @# + sum([10, 20])

@#

#@

#== DONE
change `iter(args)` magic implementstion to inbound function (custom python function func__iter(args)->IterGen )

#== dict DONE
data = {'a': 1, 'b': 2, c: [5,6,7]}

## Multiline collection constructor

#== list DONE
hellos = list
    'Hello world!'
    'Helo desktop!'

#== dict DONE
data = dict
    'a': 1
    'b': 2


#== DONE
# sugar for collections - skip commas between lines in multiline constructor


#== list slice # DONE
subVals = arr[3:-2]


#== DONE
# struct method

struct User
    name: string 

func u:User setName(name:string)
    u.name = name

# Contexts().types['User'].__typeMethods['setName'] = Function('User@setName')

user = User{name:'Markus'}
user.segName('Lukas')

print(user.name)


#== DONE
# typed func args 
func foo(name:string, age: int)


#== DONE 
# list generator
[0..10]

#== DONE
# list comprehention
[x ** 2 | x <- [0..10]]
[y * x | x <- [0..10], y <- ['a'..'n']]
[x ** 2 | x <- [0..10] | x % 2 != 0]


#== DONE
''' 
python-like
multistring
'''


#== DONE
# multiline func, definition and call (multiline in-brackets expression)

func foo (
    arg1:int,
    arg2: float,
    arg3: string 
)
    arg1 * arg2 - sum(arg3)

foo( ag1,
    arg2,
    bar( a, b, c)
)

#= DONE
# the same about for, if statements, 

# concat all sublines before make expression process

# if - DONE
if (expr1 
    && expr2)

# for - DONE
for (i=0; i<5; i += 1)

# dict DONE

d = {
    a: 1,
    b:2
}

# list DONE

nn = [1,2,
    3,4,
    5] 

# comprehension DONE
nn = [
    x + y;
    x <- nums1;
    y <- nums2;
    z = (x + y) ** 3;
    z % 5 > 1
]


#== DONE
# Lambdas, func-object, func-object call
foo = x -> x ** 2
n1 = foo(7)
foo2 = x, y -> x ** 2
n2 = foo2(5, 2)
foo3 = (x, y, z) -> (x + y) * z
n3 = foo3(2, 3, 100)


# High-order function def
#@ questions: 
1. instance of function: create, store, call
2. local context around function and into it
3. closures: how to store local declarations (local <1 lvl upper> context), controll list of used vars, or use them all?
#@

func foo(ff, arg)
    ff(arg * 2)

f1 = x -> x * 3
n1 = foo(f1, 5)
n2 = foo( x -> 2 ** x , 5)


#== DONE
# add to list or dict, back order of `<-` opertator: right add to the left
nums = []
nums <- 12
data = {}
data <- ('key', val)


#== DONE
# Type inheritanse 

struct A member1: int

struct B (A) member2: bool
# or
struct B
    type A
    member2: bool


#== DONE
# Ternar operator ==>>  expr ? expr : expr
res = condition ? valueIfTrue : valueIfFalse


#== DONE
# Val or Val operator  ?:
    `expr1 ?: expr2` # for non-number values, 
    # syntax sugar for ternar operator with condition: (expr1 != null and expr != false)
    # operator that is returns left val if it not a null/false, otherwize - return second


#== DONE
# Operator `in` as condition "collection has elem"
# for list, finds val, the same for tuple
value in [1,2,3] ...
# for dict, finds key
value in {'a':1, 'b':2,...}
# for anonimous struct?
# think about  non-word operators  instead of `in`
if 'Herakl' ?> heroes 


#== Done as `-` minus opreator for left-collection
# list pop
nums = [1,2,3]
x = nums[-1]
delete nums[-1] # nums - index; nums - [0], nums - [-1],  # 
dd = {'a':1, ..} # dd - ['a']

#== Done as `-` minus opreator for left-collection
# delete operator, find nearest context with var by name and remove it from found context
nums = [1,2,3,4,5]
x = 123
delete nums[2], x


#== DONE
# string formatting by %tpl
# string formatting by internal includes like {varName}, $varName, @varName, @{exp(res.sion)}




@#
