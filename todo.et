
# TODO List

#== change `iter(args)` magic implementstion to inbound function (custom python function func__iter(args)->IterGen )


#== store content of comments as a runtime metadata


# list | string math mult, concat

'abc' * 3 -> 'abcabcabc'
[1,2,3] * 2 -> [1,2,3,1,2,3,1,2,3]

'acb ' + 'xyz' -> 'abc xyz'
[1,2,3] + [4,5] -> [1,2,3,4,5]

#== list generator
[0..10]
[x ** 2 | x <- [0..10]]
[y * x | x <- [0..10], y <- ['a'..'n']]
[x ** 2 | x <- [0..10] | x % 2 != 0]


#== 
# Named func args

func foo(user:User, name: string, age: int)
    user ?: getUser(name, age) 
    # return user if not null, otherwize - return result of getUser()
foo(age=22, name='Vasya')


#== 
# Ternar operator >>  expr ? expr : expr
res = condition ? valueIfTrue : valueIfFalse


#==
# Operator `in`
# for list, finds val, the same for tuple
value in [1,2,3] ...
# for dict, finds key
value in {'a':1, 'b':2,...}
# think about  non-word operators  instead of `in`
if 'Herakl' ?? heroes ...
if 'Herakl' ?> heroes ...


#==
# Val or Val operator  ?:
    `expr1 ?: expr2` # for non-number values, 
    # syntax sugar for ternar operator with condition: (expr1 != null and expr != false)
    # operator that is returns left val if it not a null/false, otherwize - return second


#==
# Lambdas, func-object, func-object call
foo = \x -> x * 100
foo(2)


# High-order function def
func bar(fn:function, a:int):
    b = a ** 2
    fn([b, a, 5])


# usage
for i <- iter(20, 30)
    bar(\x -> sum(x) - 100, i)


#= 
# Native regexp
pattern cases:  /pattern/mod ; |pattern|mod ; <pattern>mod ; %pattern%mod, 
numsRx = /^[0-9]+$/in
numsRx.match(strVal) # bool
res = numRx.first(strVal) # string
resList = numRx.find(strVal) # [string]
grs = numsRx.groups(strVal) # [[string]]


#==
''' 
python-like
multistring
'''

#==
# string formatting by % , or internal includes like {varName}, $varName, @varName, @{exp(res.sion)}

#== multiline expr
# concat all sublines before make expression process

if (expr1 
    && expr2)

#==
# sub-expression in if block 
if val = foo(); val > 10 ...
# last sub is condition


#== possible sugar
# case if: with no operator between line use && or defined default operator
#    if (&& ..) if (|| .. ) - definition of default
# e.g: 
# if (||
#     a > 5
#     a % 2 != 0)
#
#


#== multiline func, definition and call

func foo (
    arg1:int,
    arg2: float,
    arg3: string 
)
    arg1 * arg2 - sum(arg3)

foo( ag1,
    arg2,
    bar( a, b, c)
)

#== concat strings
str = (
    'Hello '
    "new string!"
)

#== Next line operator, next line after beginning, 
# Second line starts with operator after 1 indent (like subline in block). 
# Next lines after 2-nd - the same indent.
res = (long_expressions)
    + (next-expression) * (next-expression)
    - (3rd-line--expression)

# not sure about if-conditions:
if long-condition
    || next-condition && condition
    || 3rd-condition && condition
    if-block-expressions

#== else if - sugar for `if` into `else` block 
if cond2
    expr1
else if cond2
    expr2
else
    expr3

#== Think about tail-recursion.
Tranform tail recursion to loop.

func foo(arg)
    if expr1
        return expr2
    arg2 = expr3
    foo(arg2)

@#

#@

--------- Done section: 


#== DONE!
#@ 
multiline comment

x = 2 #@ inline comment @# + sum([10, 20])

@#
#@


#== dict DONE
data = {'a': 1, 'b': 2, c: [5,6,7]}

## Multiline collection constructor

#== list DONE
hellos = list
    'Hello world!'
    'Helo desktop!'

#== dict DONE
data = dict
    'a': 1
    'b': 2


#== DONE
# sugar for collections - skip commas between lines in multiline constructor


#== list slice # DONE
subVals = arr[3:-2]


#== DONE
# struct method

struct User
    name: string 

func u:User setName(name:string)
    u.name = name

# Contexts().types['User'].__typeMethods['setName'] = Function('User@setName')

user = User{name:'Markus'}
user.segName('Lukas')

print(user.name)


#== DONE
# typed func args 
func foo(name:string, age: int)


@#
